-- Udacity - Udiddit

--start postgres and switch user from root to postgres
service postgresql start && su - postgres 

--init database bad-db.sql
psql -f /home/workspace/nd072-c2-dbms/project/starter/bad-db.sql

--enterd the database
psql 

------------------------Part I: Investigate the existing schema

--introspection commands
-- list * schamas and tables
\dt *.*

--list tables in current database
\dt
\d
\d+

-- check structure of a table
SELECT column_name, data_type, character_maximum_length, is_nullable, column_default
FROM INFORMATION_SCHEMA.COLUMNS where table_name ="bad_comments";

SELECT column_name, data_type, character_maximum_length, is_nullable, column_default
FROM INFORMATION_SCHEMA.COLUMNS where table_name ="bad_posts";

-- check few rows
SELECT * 
FROM bad_comments LIMIT 10;

SELECT * 
FROM bad_posts LIMIT 10;

--------------------------Part II: Create the DDL for your new schema

-- 1.	Guideline #1: here is a list of features and specifications that Udiddit needs in order to support its website and administrative interface:
-- a.	Allow new users to register:
-- i.	Each username has to be unique
-- ii.	Usernames can be composed of at most 25 characters
-- iii.	Usernames can’t be empty
-- iv.	We won’t worry about user passwords for this project

CREATE TABLE users(
	id SERIAL PRIMARY KEY,
	username VARCHAR(25) UNIQUE NOT NULL,
	last_login TIMESTAMP--,
	--CONSTRAINT "non_empty_username" CHECK (LENGTH(TRIM("username")) > 0)
);
--create index to list all users who haven’t logged in in the last year
--CREATE INDEX "find_users" ON users (LOWER("username"));

-- b.	Allow registered users to create new topics:
-- i.	Topic names have to be unique.
-- ii.	The topic’s name is at most 30 characters
-- iii.	The topic’s name can’t be empty
-- iv.	Topics can have an optional description of at most 500 characters.
CREATE TABLE topics(
	id SERIAL PRIMARY KEY,
	topicname VARCHAR(30) UNIQUE NOT NULL,
	description VARCHAR(500)--,
	--CONSTRAINT "non_empty_topicname" CHECK (LENGTH(TRIM("topicname")) > 0)
);
--create index to list all topics that don’t have any posts
CREATE INDEX "list_topic" ON topics ("id");
--create index quickly find a topic
--CREATE INDEX "find_topic" ON topics (LOWER("topicname") VARCHAR_PATTERN_OPS);

-- c.	Allow registered users to create new posts on existing topics:
-- i.	Posts have a required title of at most 100 characters
-- ii.	The title of a post can’t be empty.
-- iii.	Posts should contain either a URL or a text content, but not both.
-- iv.	If a topic gets deleted, all the posts associated with it should be automatically deleted too.
-- v.	If the user who created the post gets deleted, then the post will remain, but it will become dissociated from that user.
CREATE TABLE posts(
	id SERIAL PRIMARY KEY,
	posttitle VARCHAR(100) NOT NULL,
	created_on TIMESTAMP,
	url TEXT,
	text_content TEXT, 
	topic_id INTEGER NOT NULL, 
	user_id INTEGER REFERENCES "users" ON DELETE SET NULL,
	--CONSTRAINT "non_empty_posttitle" CHECK (LENGTH(TRIM("posttitle")) > 0),
	CONSTRAINT "url_text" CHECK(
			(LENGTH(TRIM("url")) > 0 AND LENGTH(TRIM("text_content")) = 0) OR
    		(LENGTH(TRIM("url")) = 0 AND LENGTH(TRIM("text_content")) > 0)
			),
	CONSTRAINT "fk_topic" FOREIGN KEY ("topic_id") REFERENCES "topics" ("id") ON DELETE CASCADE
);
--create index quickly find a post by partial words
CREATE INDEX "find_post" ON "posts" (LOWER("posttitle") VARCHAR_PATTERN_OPS);

-- d.	Allow registered users to comment on existing posts:
-- i.	A comment’s text content can’t be empty.
-- ii.	Contrary to the current linear comments, the new structure should allow comment threads at arbitrary levels.
-- iii.	If a post gets deleted, all comments associated with it should be automatically deleted too.
-- iv.	If the user who created the comment gets deleted, then the comment will remain, but it will become dissociated from that user.
-- v.	If a comment gets deleted, then all its descendants in the thread structure should be automatically deleted too.
CREATE TABLE comments(
	id SERIAL PRIMARY KEY,
	comment TEXT NOT NULL,
	created_on TIMESTAMP,
	post_id BIGINT NOT NULL,
	user_id INTEGER REFERENCES "users" ON DELETE SET NULL,
	parent_id BIGINT,
	CONSTRAINT "delete_child_comment" FOREIGN KEY ("parent_id") REFERENCES "comments" ON DELETE CASCADE,
	CONSTRAINT "fk_post" FOREIGN KEY ("post_id") REFERENCES "posts" ("id") ON DELETE CASCADE

);
--create index quickly find a comment by partial words
CREATE INDEX "find_comment" ON "comments" (LOWER("comment") VARCHAR_PATTERN_OPS);

-- e.	Make sure that a given user can only vote once on a given post:
-- i.	Hint: you can store the (up/down) value of the vote as the values 1 and -1 respectively.
-- ii.	If the user who cast a vote gets deleted, then all their votes will remain, but will become dissociated from the user.
-- iii.	If a post gets deleted, then all the votes for that post should be automatically deleted too.

CREATE TABLE votes(
	id SERIAL PRIMARY KEY,
	vote SMALLINT NOT NULL,
	post_id BIGINT NOT NULL,
	user_id INTEGER REFERENCES "users" ON DELETE SET NULL,
	CONSTRAINT "vote_once" UNIQUE (user_id, post_id),
	CONSTRAINT "vote_values" CHECK ("vote" = 1 OR "vote" = -1),
	CONSTRAINT "fk_post" FOREIGN KEY ("post_id") REFERENCES "posts" ("id") ON DELETE CASCADE

);


--------------------------Part III: Migrate the provided data
-- 1.	Topic descriptions can all be empty
-- 2.	Since the bad_comments table doesn’t have the threading feature, you can migrate all comments
--  as top-level comments, i.e. without a parent
-- 3.	You can use the Postgres string function regexp_split_to_table to unwind the comma-separated votes values into separate rows
-- 4.	Don’t forget that some users only vote or comment, and haven’t created any posts. You’ll have to create those users too.
-- 5.	The order of your migrations matter! For example, since posts depend on users and topics, you’ll have to migrate the latter first.
-- 6.	Tip: You can start by running only SELECTs to fine-tune your queries, and use a LIMIT to avoid large data sets. 
--   Once you know you have the correct query, you can then run your full INSERT...SELECT query.
-- 7.	NOTE: The data in your SQL Workspace contains thousands of posts and comments. 
--   The DML queries may take at least 10-15 seconds to run.

--users
INSERT INTO users("username")
	SELECT DISTINCT username
		FROM bad_comments
	UNION SELECT DISTINCT username
		FROM bad_posts
	UNION SELECT DISTINCT regexp_split_to_table(upvotes, ',')
		FROM  bad_posts
	UNION SELECT DISTINCT regexp_split_to_table(downvotes, ',')
		FROM  bad_posts;

--topics
INSERT INTO topics("topicname")
	SELECT DISTINCT topic
		FROM bad_posts ;


--posts
INSERT INTO posts("posttitle", "url", "text_content", "topic_id", "user_id")
	SELECT LEFT(bad.title, 100), bad.url, bad.text_content, t.id, u.id
		FROM bad_posts as bad
	JOIN topics as t
		ON t.topicname = bad.topic
	JOIN users as u
		ON u.username = bad.username;


--comments
INSERT INTO comments("comment", "post_id", "user_id")
	SELECT bad.text_content, p.id, p.user_id
		FROM bad_comments as bad
	JOIN users as u
		ON u.username = bad.username
	JOIN posts as p
		ON p.id = bad.post_id
	;

--votes
--upvotes
INSERT INTO votes("vote", "post_id", "user_id")
	SELECT 1, post_id, user_id
	FROM (SELECT id AS post_id, REGEXP_SPLIT_TO_TABLE(upvotes, ',') AS username
		FROM bad_posts) bad
	JOIN users ON users.username=bad.username
	;


--downvotes
INSERT INTO votes("vote", "post_id", "user_id")
	SELECT 1, post_id, user_id
	FROM (SELECT id AS post_id, REGEXP_SPLIT_TO_TABLE(downvotes, ',') AS username
		FROM bad_posts) bad
	JOIN users ON users.username=bad.username
	;


---------ADDITIONAL PART, DQL:
-- Guideline #2: here is a list of queries that Udiddit needs in order to support its website and administrative interface. Note that you don’t need to produce the DQL for those queries: they are only provided to guide the design of your new database schema.
-- a. List all users who haven’t logged in in the last year.
SELECT id
FROM users
WHERE last_login <= (CURRENT_DATE - interval '1 year')
;
-- b. List all users who haven’t created any post.
SELECT username
FROM users 
WHERE id NOT IN (SELECT DISTINCT user_id FROM posts)
;
-- c. Find a user by their username.
SELECT *
FROM users
WHERE username LIKE 'A%';
-- d. List all topics that don’t have any posts.
SELECT *
FROM topics 
WHERE id NOT IN (SELECT DISTINCT topic_id FROM posts)
;
-- e. Find a topic by its name.
SELECT *
FROM topics
WHERE topicname LIKE 'A%';
-- f. List the latest 20 posts for a given topic.
SELECT posttitle, url, text_content
FROM posts
WHERE topic_id IN (SELECT id FROM topics WHERE topicname = 'Eritrea')
ORDER BY id DESC
LIMIT 20;
-- g. List the latest 20 posts made by a given user.
SELECT posttitle, url, text_content
FROM posts
WHERE user_id IN (SELECT id FROM users WHERE username = 'Aaron18')
ORDER BY id DESC
LIMIT 20;
-- h. Find all posts that link to a specific URL, for moderation purposes. 
SELECT *
FROM posts 
WHERE url = 'http://lesley.com';
-- i. List all the top-level comments (those that don’t have a parent comment) for a given post.
SELECT comment
FROM comments
WHERE parent_id IS NULL;
-- j. List all the direct children of a parent comment.
SELECT comment 
FROM comments
WHERE parent_id = 1;
-- k. List the latest 20 comments made by a given user.
SELECT comment
FROM comments
WHERE user_id IN (SELECT id FROM users WHERE username = 'Aaron18')
ORDER BY id DESC
LIMIT 20;
-- l. Compute the score of a post, defined as the difference between the number of upvotes and the number of downvotes
SELECT post_id, SUM(vote) as post_score
FROM votes
GROUP BY post_id;
